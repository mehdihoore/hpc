<!DOCTYPE html>
<html lang="fa" dir="rtl">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>پروژه بیمارستان هزار تخت خوابی قم</title>
    <style>
      body {
        font-family: "Tahoma", "Vazirmatn", sans-serif;
        margin: 0;
        display: flex;
        flex-direction: column;
        align-items: center;
        padding: 10px;
        box-sizing: border-box;
        text-align: right;
      }
      /* Removed .controls and .controls label, .controls select styles */

      .navigation-controls {
        margin-bottom: 10px;
        display: flex;
        flex-wrap: wrap;
        align-items: center;
        gap: 10px;
        justify-content: center;
      }
      .navigation-controls button {
        padding: 8px 12px;
        border-radius: 4px;
        border: 1px solid #007bff;
        background-color: #007bff;
        color: white;
        cursor: pointer;
        font-family: inherit;
      }
      .navigation-controls button:hover {
        background-color: #0056b3;
      }

      .layer-controls {
        margin-bottom: 15px;
        padding: 10px;
        border: 1px solid #ddd;
        border-radius: 5px;
        display: flex;
        flex-wrap: wrap;
        gap: 8px;
        justify-content: center;
      }
      .layer-controls button {
        padding: 6px 10px;
        border-radius: 4px;
        border: 1px solid #ccc;
        background-color: #f8f9fa;
        cursor: pointer;
        font-family: inherit;
      }
      .layer-controls button.active {
        background-color: #007bff;
        color: white;
        border-color: #007bff;
      }
      .layer-controls button.inactive {
        background-color: #e9ecef;
        color: #495057;
      }

      h1,
      p.description {
        text-align: center;
        margin-bottom: 10px;
      }
      #svgContainer {
        width: 90vw;
        height: 65vh;
        max-width: 1200px;
        border: 1px solid #007bff;
        background-color: #e9ecef;
        overflow: hidden;
        margin: 10px auto;
        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
        display: flex;
        justify-content: center;
        align-items: center;
        cursor: grab;
        position: relative;
      }
      #svgContainer.dragging {
        cursor: grabbing;
      }
      #svgContainer.loading::before {
        content: "در حال بارگذاری SVG...";
        font-style: italic;
        color: #666;
      }
      #svgContainer svg {
        display: block;
        width: 100%;
        height: 100%;
      }

      .interactive-element {
        cursor: pointer;
        transition: all 0.2s ease;
      }

      .interactive-element:hover {
        filter: brightness(1.1); /* Simpler hover */
      }
      .form-popup {
        display: none;
        position: fixed;
        bottom: 10px;
        left: 10px;
        border: 2px solid #555;
        z-index: 10;
        background-color: #f9f9f9;
        padding: 15px;
        box-shadow: 0px 0px 15px rgba(0, 0, 0, 0.3);
        border-radius: 5px;
        max-width: 95vw;
        max-height: 80vh;
        overflow: auto;
      }
      .form-popup h3 {
        margin-top: 0;
        text-align: center;
        border-bottom: 1px solid #ccc;
        padding-bottom: 10px;
      }
      .form-popup table {
        width: 100%;
        border-collapse: collapse;
        margin-top: 10px;
        font-size: 0.9em;
      }
      .form-popup th,
      .form-popup td {
        border: 1px solid #ddd;
        padding: 6px;
        text-align: right;
        vertical-align: middle;
      }
      .form-popup th {
        background-color: #f2f2f2;
        font-weight: bold;
      }
      .form-popup .notes {
        margin-top: 15px;
        font-size: 0.8em;
        white-space: pre-line;
      }
      .form-popup .btn-container {
        text-align: left;
        margin-top: 15px;
      }
      .form-popup .btn {
        padding: 8px 12px;
        background-color: #007bff;
        color: white;
        border: none;
        cursor: pointer;
        margin-right: 5px;
        border-radius: 3px;
      }
      .form-popup .btn.cancel {
        background-color: #dc3545;
      }
      .form-popup .btn:hover {
        opacity: 0.9;
      }
      .highlight-issue {
        background-color: #fff3cd;
        font-weight: bold;
        text-align: center;
      }

      .zoom-controls {
        position: absolute;
        top: 10px;
        right: 10px;
        z-index: 5;
        display: flex;
        flex-direction: column;
        gap: 5px;
      }

      .zoom-controls button {
        padding: 8px 12px;
        background-color: #007bff;
        color: white;
        border: none;
        border-radius: 4px;
        cursor: pointer;
        font-size: 16px;
        font-weight: bold;
      }

      .zoom-controls button:hover {
        background-color: #0056b3;
      }

      .zoom-controls button:disabled {
        background-color: #6c757d;
        cursor: not-allowed;
      }
    </style>
  </head>

  <body>
    <h1>پروژه بیمارستان هزار تخت خوابی قم</h1>

    <div class="layer-controls" id="layerControlsContainer">
      <!-- Layer toggle buttons will be added here by JavaScript -->
    </div>

    <div class="navigation-controls">
      <button id="backToPlanBtn">بازگشت به پلن اصلی</button>
    </div>
    <div
      id="regionZoneNavContainer"
      style="
        margin-bottom: 15px;
        padding: 10px;
        border: 1px solid #ddd;
        border-radius: 5px;
        display: none;
        flex-direction: column;
        align-items: center;
        gap: 10px;
        width: 80%;
        max-width: 600px;
        background-color: #f8f9fa;
      "
    >
      <h3 style="margin-top: 0; margin-bottom: 10px">ناوبری سریع به زون‌ها</h3>
      <div style="margin-bottom: 10px; width: 100%; text-align: center">
        <label for="regionSelect" style="margin-left: 5px; font-weight: bold"
          >انتخاب محدوده (بلاک):</label
        >
        <select
          id="regionSelect"
          style="
            padding: 5px;
            border-radius: 3px;
            border: 1px solid #ccc;
            min-width: 200px;
          "
        >
          <option value="">-- ابتدا یک محدوده انتخاب کنید --</option>
        </select>
      </div>
      <div
        id="zoneButtonsContainer"
        style="
          display: flex;
          flex-wrap: wrap;
          gap: 8px;
          justify-content: center;
          margin-top: 5px;
        "
      >
        <!-- Zone buttons will be dynamically added here by JavaScript -->
      </div>
    </div>
    <p class="description">
      برای مشاهده چک لیست، روی المان مربوطه در نقشه کلیک کنید. اگر در پلن اصلی
      هستید، روی نام زون کلیک کنید تا نقشه آن بارگذاری شود.
    </p>
    <div id="svgContainer"></div>

    <!-- GFRC Form -->
    <div class="form-popup" id="gfrcChecklistForm">
      <h3 id="gfrcFormTitle">چک لیست کنترل کیفی - GFRC</h3>
      <div id="gfrcStaticData">
        <p><strong>پیمانکار:</strong> <span id="gfrcContractor"></span></p>
        <p><strong>محدوده:</strong> <span id="gfrcArea"></span></p>
        <p><strong>بلوک:</strong> <span id="gfrcBlock"></span></p>
        <p><strong>وضع تحویل:</strong> <span id="gfrcDeliveryStatus"></span></p>
        <p><strong>نوع پنل:</strong> <span id="gfrcPanelType"></span></p>
        <p>
          <strong>شماره پنل بازگشایی شده:</strong>
          <span id="gfrcPanelNumber"></span>
        </p>
      </div>
      <table>
        <thead>
          <tr>
            <th>شرح بررسی</th>
            <th>وضعیت / مقدار</th>
          </tr>
        </thead>
        <tbody id="gfrcChecklistBody"></tbody>
      </table>
      <div class="notes" id="gfrcNotes"></div>
      <div class="btn-container">
        <button
          type="button"
          class="btn cancel"
          onclick="closeForm('gfrcChecklistForm')"
        >
          بستن
        </button>
      </div>
    </div>

    <!-- Glass Form -->
    <div class="form-popup" id="glassChecklistForm">
      <h3 id="glassFormTitle">چک لیست کنترل کیفی - شیشه</h3>
      <div id="glassStaticData">
        <p><strong>پیمانکار:</strong> <span id="glassContractor"></span></p>
        <p><strong>محدوده:</strong> <span id="glassArea"></span></p>
        <p><strong>نوع شیشه:</strong> <span id="glassType"></span></p>
        <p><strong>شماره المان:</strong> <span id="glassNumber"></span></p>
      </div>
      <table>
        <thead>
          <tr>
            <th>شرح بررسی</th>
            <th>وضعیت / مقدار</th>
          </tr>
        </thead>
        <tbody id="glassChecklistBody"></tbody>
      </table>
      <div class="notes" id="glassNotes"></div>
      <div class="btn-container">
        <button
          type="button"
          class="btn cancel"
          onclick="closeForm('glassChecklistForm')"
        >
          بستن
        </button>
      </div>
    </div>

    <!-- Mullion/Transom Form -->
    <div class="form-popup" id="mullionChecklistForm">
      <h3 id="mullionFormTitle">چک لیست کنترل کیفی - مولیون/ترنزوم</h3>
      <div id="mullionStaticData">
        <p><strong>پیمانکار:</strong> <span id="mullionContractor"></span></p>
        <p><strong>محدوده:</strong> <span id="mullionArea"></span></p>
        <p><strong>نوع المان:</strong> <span id="mullionType"></span></p>
        <p><strong>شماره المان:</strong> <span id="mullionNumber"></span></p>
      </div>
      <table>
        <thead>
          <tr>
            <th>شرح بررسی</th>
            <th>وضعیت / مقدار</th>
          </tr>
        </thead>
        <tbody id="mullionChecklistBody"></tbody>
      </table>
      <div class="notes" id="mullionNotes"></div>
      <div class="btn-container">
        <button
          type="button"
          class="btn cancel"
          onclick="closeForm('mullionChecklistForm')"
        >
          بستن
        </button>
      </div>
    </div>
    <div class="form-popup" id="bazshowChecklistForm">
      <h3 id="bazshowFormTitle">چک لیست کنترل کیفی - بازشو</h3>
      <div id="bazshowStaticData">
        <p><strong>پیمانکار:</strong> <span id="bazshowContractor"></span></p>
        <p><strong>محدوده:</strong> <span id="bazshowArea"></span></p>
        <p>
          <strong>شماره المان:</strong> <span id="bazshowElementNumber"></span>
        </p>
      </div>
      <table>
        <thead>
          <tr>
            <th>شرح بررسی</th>
            <th>وضعیت / مقدار</th>
          </tr>
        </thead>
        <tbody id="bazshowChecklistBody"></tbody>
      </table>
      <div class="notes" id="bazshowNotes"></div>
      <div class="btn-container">
        <button
          type="button"
          class="btn cancel"
          onclick="closeForm('bazshowChecklistForm')"
        >
          بستن
        </button>
      </div>
    </div>
    <script>
      let currentZoom = 1;
      const zoomStep = 0.2;
      const minZoom = 0.5;
      const maxZoom = 40;
      let currentSvgElement = null;
      let currentHoveredElement = null;

      //pan variables
      let isPanning = false;
      let panStartX = 0;
      let panStartY = 0;
      let panX = 0;
      let panY = 0;
      let lastTouchDistance = 0;
      // --- Global context for the current plan ---
      let currentPlanFileName = "Plan.svg"; // To help find current plan's defaults
      let currentPlanZoneName = "نامشخص";
      let currentPlanDefaultContractor = "پیمانکار عمومی";
      let currentPlanDefaultBlock = "بلوک عمومی";
      let currentSvgAxisMarkersX = [];
      let currentSvgAxisMarkersY = [];
      let currentSvgHeight = 2200; // Default, will be updated
      let currentSvgWidth = 3000; // Default, will be updated
      // --- Configuration for SVG Groups ---
      const svgGroupConfig = {
        GFRC: {
          label: "GFRC",
          defaultVisible: true,
          interactive: true,
          elementType: "GFRC", // For generic processing
        },
        Atieh: {
          label: "بلوک A- آتیه نما",
          color: "#0de16d",
          defaultVisible: true,
          interactive: true,
          contractor: "شرکت آتیه نما",
          block: "A",
          elementType: "Region",
        },
        org: {
          label: "بلوک - اورژانس A- آتیه نما",
          color: "#ebb00d",
          defaultVisible: true,
          interactive: true,
          contractor: "شرکت آتیه نما",
          block: "A - اورژانس",
          elementType: "Region",
        },
        AranB: {
          label: "بلوک B-آرانسج",
          color: "#38abee",
          defaultVisible: true,
          interactive: true,
          contractor: "شرکت آرانسج",
          block: "B",
          elementType: "Region",
        },
        AranC: {
          label: "بلوک C-آرانسج",
          color: "#ee3838",
          defaultVisible: true,
          interactive: true,
          contractor: "شرکت آرانسج",
          block: "C",
          elementType: "Region",
        },
        hayatOmran: {
          label: " حیاط عمران آذرستان",
          color: "#eef595da",
          defaultVisible: true,
          interactive: true,
          contractor: "شرکت عمران آذرستان",
          block: "حیاط",
          elementType: "Region",
        },
        hayatRos: {
          label: " حیاط رس",
          color: "#eb0de7da",
          defaultVisible: true,
          interactive: true,
          contractor: "شرکت ساختمانی رس",
          block: "حیاط",
          elementType: "Region",
        },
        handrail: {
          label: "نقشه ندارد",
          color: "#ee3838",
          defaultVisible: true,
          interactive: true,
        },
        "glass_40%": {
          label: "شیشه 40%",
          color: "rgba(173, 216, 230, 0.7)",
          defaultVisible: true,
          interactive: true,
          elementType: "Glass",
        },
        glass_opaque: {
          label: "شیشه مات",
          color: "rgba(144, 238, 144, 0.7)",
          defaultVisible: true,
          interactive: true,
          elementType: "Glass",
        },
        "glass_80%": {
          label: "شیشه 80%",
          color: "rgba(255, 255, 102, 0.7)",
          defaultVisible: true,
          interactive: true,
          elementType: "Glass",
        },
        Mullion: {
          label: "مولیون",
          color: "rgba(128, 128, 128, 0.9)",
          defaultVisible: true,
          interactive: true,
          elementType: "Mullion",
        },
        Transom: {
          label: "ترنزوم",
          color: "rgba(169, 169, 169, 0.9)",
          defaultVisible: true,
          interactive: true,
          elementType: "Transom",
        },
        Bazshow: {
          label: "بازشو",
          color: "rgba(169, 169, 169, 0.9)",
          defaultVisible: true,
          interactive: true,
          elementType: "Bazshow",
        },
        GLASS: {
          label: "شیشه",
          color: "#eef595da",
          defaultVisible: true,
          interactive: true,
          elementType: "Glass",
        },
      };
      const regionToZoneMap = {
        Atieh: [
          // Key should match a key in svgGroupConfig, e.g., for "بلوک A- آتیه نما"
          { label: "زون 1 (مثال آتیه)", svgFile: "Zone01.svg" },
          { label: "زون 2 (مثال آتیه)", svgFile: "Zone02.svg" },
        ],
        org: [
          // For "بلوک - اورژانس A- آتیه نما"
          { label: "زون اورژانس (مثال)", svgFile: "ZoneEmergency.svg" }, // Ensure this SVG file exists
        ],
        AranB: [
          // For "بلوک B-آرانسج"
          { label: "زون 9 (مثال آرانسج B)", svgFile: "Zone09.svg" },
          { label: "زون 10 (مثال آرانسج B)", svgFile: "Zone10.svg" },
        ],
        AranC: [
          // For "بلوک C-آرانسج"
          { label: "زون 11 (مثال آرانسج C)", svgFile: "Zone11.svg" },
        ],
        hayatOmran: [
          // For "حیاط عمران آذرستان"
          { label: "زون حیاط عمران (مثال)", svgFile: "ZoneHayatOmran.svg" }, // Ensure this SVG file exists
        ],
        hayatRos: [
          // For "حیاط رس"
          { label: "زون حیاط رس (مثال)", svgFile: "ZoneHayatRas.svg" }, // Ensure this SVG file exists
        ],
        // Add other regions and their respective zones here.
        // Example for a region not in svgGroupConfig (if needed, but ensure consistency):
        // "OtherRegion": [
        //  { label: "Zone X", svgFile: "ZoneX.svg" }
        // ]
      };
      // --- Sample Data Store for All Checklists ---
      const panelChecklistDataStore = {
        GFRC: {
          // These are general static info, specific panel data is in 'panels'
          // Some of these will be overridden by dynamic data
          staticInfo: {
            contractor: "شرکت ساختمانی آتیه نما (پیش‌فرض کلی)", // Default if not found dynamically
            area: "محدوده پیش‌فرض کلی",
            block: "بلوک پیش‌فرض کلی",
            deliveryStatus: "نما تحویل نظارت گردیده است",
            notes:
              "×: عدم تطابق\nA: نوع ایراد استفاده از جوش به جای پیچ\nB: نوع ایراد برش نبشی\nC: استفاده اشتباه از کلمپ های با طول غیر یکسان\nاعداد کنار حروف انگلیسی: تعداد ایرادات مشاهده شده می باشد",
          },
          panels: {
            "FF-01(AT)": {
              panelType: "عمودی",
              panelNumber: "1 (مثال)",
              items: [
                { check: "مطابقت فیس نمای نصب شده با شاپ", value: "6mm" },
                {
                  check: "هم راستایی و موقعیت اتصال کیل پشت پنل GFRC",
                  value: "6mm",
                },
                { check: "مطابقت موقعیت نبشی زیرسازی با شاپ", value: "×" },
                { check: "بررسی عملکرد پیچ ریگلاژ کیل ردیف اول", value: "" },
                { check: "نصب کامل اتصالات کیل", value: "×" },
                { check: "فلزی بودن اتصالات کیل", value: "" },
                { check: "لاستیک پشت اتصالات کیل", value: "×" },
                { check: "دفرمگی اتصالات کیل", value: "" },
                { check: "انطباق با جزئیات مصوب", value: "A7,C" },
                { check: "اجرای صحیح پلیتهای کاشته شده", value: "×" },
                { check: "اجرای کامل پیچ و مهره", value: "" },
                { check: "جوشکاری اتصالات زیرسازی", value: "×" },
                { check: "پلیت اتصال تیر به ستون", value: "" },
                { check: "دفرمگی نبشی های زیرسازی", value: "" },
                { check: "ضد زنگ زیرسازی", value: "" },
                { check: "وضعیت ورق گالوانیزه", value: "" },
                { check: "وضعیت پشم سنگ", value: "" },
                { check: "وضعیت درزبندی", value: "" },
                { check: "ملاحظات دیگر", value: "نیاز به بررسی مجدد" },
              ],
            },
            "RF-01(AT)": {
              panelType: "عمودی",
              panelNumber: "1 (مثال)",
              items: [
                { check: "مطابقت فیس نمای نصب شده با شاپ", value: "6mm" },
                {
                  check: "هم راستایی و موقعیت اتصال کیل پشت پنل GFRC",
                  value: "6mm",
                },
                { check: "مطابقت موقعیت نبشی زیرسازی با شاپ", value: "×" },
                { check: "بررسی عملکرد پیچ ریگلاژ کیل ردیف اول", value: "" },
                { check: "نصب کامل اتصالات کیل", value: "×" },
                { check: "فلزی بودن اتصالات کیل", value: "" },
                { check: "لاستیک پشت اتصالات کیل", value: "×" },
                { check: "دفرمگی اتصالات کیل", value: "" },
                { check: "انطباق با جزئیات مصوب", value: "A7,C" },
                { check: "اجرای صحیح پلیتهای کاشته شده", value: "×" },
                { check: "اجرای کامل پیچ و مهره", value: "" },
                { check: "جوشکاری اتصالات زیرسازی", value: "×" },
                { check: "پلیت اتصال تیر به ستون", value: "" },
                { check: "دفرمگی نبشی های زیرسازی", value: "" },
                { check: "ضد زنگ زیرسازی", value: "" },
                { check: "وضعیت ورق گالوانیزه", value: "" },
                { check: "وضعیت پشم سنگ", value: "" },
                { check: "وضعیت درزبندی", value: "" },
                { check: "ملاحظات دیگر", value: "نیاز به بررسی مجدد" },
              ],
            },
            "UL-01(AT)": {
              panelType: "عمودی",
              panelNumber: "1 (مثال)",
              items: [
                { check: "مطابقت فیس نمای نصب شده با شاپ", value: "6mm" },
                {
                  check: "هم راستایی و موقعیت اتصال کیل پشت پنل GFRC",
                  value: "6mm",
                },
                { check: "مطابقت موقعیت نبشی زیرسازی با شاپ", value: "×" },
                { check: "بررسی عملکرد پیچ ریگلاژ کیل ردیف اول", value: "" },
                { check: "نصب کامل اتصالات کیل", value: "×" },
                { check: "فلزی بودن اتصالات کیل", value: "" },
                { check: "لاستیک پشت اتصالات کیل", value: "×" },
                { check: "دفرمگی اتصالات کیل", value: "" },
                { check: "انطباق با جزئیات مصوب", value: "A7,C" },
                { check: "اجرای صحیح پلیتهای کاشته شده", value: "×" },
                { check: "اجرای کامل پیچ و مهره", value: "" },
                { check: "جوشکاری اتصالات زیرسازی", value: "×" },
                { check: "پلیت اتصال تیر به ستون", value: "" },
                { check: "دفرمگی نبشی های زیرسازی", value: "" },
                { check: "ضد زنگ زیرسازی", value: "" },
                { check: "وضعیت ورق گالوانیزه", value: "" },
                { check: "وضعیت پشم سنگ", value: "" },
                { check: "وضعیت درزبندی", value: "" },
                { check: "ملاحظات دیگر", value: "نیاز به بررسی مجدد" },
              ],
            },
            "FL-01(AT)": {
              panelType: "افقی",
              panelNumber: "2 (مثال)",
              items: [
                { check: "مطابقت فیس نمای نصب شده با شاپ", value: "12mm" },
                {
                  check: "هم راستایی و موقعیت اتصال کیل پشت پنل GFRC",
                  value: "12mm",
                },
                { check: "مطابقت موقعیت نبشی زیرسازی با شاپ", value: "×" },
                {
                  check: "بررسی عملکرد پیچ ریگلاژ کیل ردیف اول",
                  value: "بررسی شده",
                },
                { check: "نصب کامل اتصالات کیل", value: "×" },
                { check: "فلزی بودن اتصالات کیل", value: "مطابق" },
                { check: "لاستیک پشت اتصالات کیل", value: "×" },
                { check: "دفرمگی اتصالات کیل", value: "" },
                { check: "انطباق با جزئیات مصوب", value: "A24,B7" },
                { check: "اجرای صحیح پلیتهای کاشته شده", value: "" },
                { check: "اجرای کامل پیچ و مهره", value: "×" },
                { check: "جوشکاری اتصالات زیرسازی", value: "" },
                { check: "پلیت اتصال تیر به ستون", value: "×" },
                { check: "دفرمگی نبشی های زیرسازی", value: "×" },
                { check: "ضد زنگ زیرسازی", value: "×" },
                { check: "وضعیت ورق گالوانیزه", value: "" },
                { check: "وضعیت پشم سنگ", value: "" },
                { check: "وضعیت درزبندی", value: "" },
                { check: "ملاحظات دیگر", value: "" },
              ],
            },
            "UL-01(AT)": {
              panelType: "افقی",
              panelNumber: "2 (مثال)",
              items: [
                { check: "مطابقت فیس نمای نصب شده با شاپ", value: "12mm" },
                {
                  check: "هم راستایی و موقعیت اتصال کیل پشت پنل GFRC",
                  value: "12mm",
                },
                { check: "مطابقت موقعیت نبشی زیرسازی با شاپ", value: "×" },
                {
                  check: "بررسی عملکرد پیچ ریگلاژ کیل ردیف اول",
                  value: "بررسی شده",
                },
                { check: "نصب کامل اتصالات کیل", value: "×" },
                { check: "فلزی بودن اتصالات کیل", value: "مطابق" },
                { check: "لاستیک پشت اتصالات کیل", value: "×" },
                { check: "دفرمگی اتصالات کیل", value: "" },
                { check: "انطباق با جزئیات مصوب", value: "A24,B7" },
                { check: "اجرای صحیح پلیتهای کاشته شده", value: "" },
                { check: "اجرای کامل پیچ و مهره", value: "×" },
                { check: "جوشکاری اتصالات زیرسازی", value: "" },
                { check: "پلیت اتصال تیر به ستون", value: "×" },
                { check: "دفرمگی نبشی های زیرسازی", value: "×" },
                { check: "ضد زنگ زیرسازی", value: "×" },
                { check: "وضعیت ورق گالوانیزه", value: "" },
                { check: "وضعیت پشم سنگ", value: "" },
                { check: "وضعیت درزبندی", value: "" },
                { check: "ملاحظات دیگر", value: "" },
              ],
            },
            "DL-01": {
              panelType: "افقی",
              panelNumber: "2 (مثال)",
              items: [
                { check: "مطابقت فیس نمای نصب شده با شاپ", value: "12mm" },
                {
                  check: "هم راستایی و موقعیت اتصال کیل پشت پنل GFRC",
                  value: "12mm",
                },
                { check: "مطابقت موقعیت نبشی زیرسازی با شاپ", value: "×" },
                {
                  check: "بررسی عملکرد پیچ ریگلاژ کیل ردیف اول",
                  value: "بررسی شده",
                },
                { check: "نصب کامل اتصالات کیل", value: "×" },
                { check: "فلزی بودن اتصالات کیل", value: "مطابق" },
                { check: "لاستیک پشت اتصالات کیل", value: "×" },
                { check: "دفرمگی اتصالات کیل", value: "" },
                { check: "انطباق با جزئیات مصوب", value: "A24,B7" },
                { check: "اجرای صحیح پلیتهای کاشته شده", value: "" },
                { check: "اجرای کامل پیچ و مهره", value: "×" },
                { check: "جوشکاری اتصالات زیرسازی", value: "" },
                { check: "پلیت اتصال تیر به ستون", value: "×" },
                { check: "دفرمگی نبشی های زیرسازی", value: "×" },
                { check: "ضد زنگ زیرسازی", value: "×" },
                { check: "وضعیت ورق گالوانیزه", value: "" },
                { check: "وضعیت پشم سنگ", value: "" },
                { check: "وضعیت درزبندی", value: "" },
                { check: "ملاحظات دیگر", value: "" },
              ],
            },
          },
        },
        Glass: {
          staticInfo: {
            contractor: "شرکت شیشه سازی نوین",
            area: "زون 9 ضلع شرقی",
            notes: "بررسی کیفیت شیشه و نصب آن",
          },
          panels: {
            glass_default: {
              glassType: "شیشه دوجداره",
              elementNumber: "G-001",
              items: [
                { check: "کیفیت شیشه", value: "مطابق استاندارد" },
                { check: "نصب صحیح", value: "بررسی شده" },
                { check: "درزبندی", value: "×" },
                { check: "تمیزی سطح", value: "مطابق" },
                { check: "عدم خراش", value: "مطابق" },
              ],
            },
          },
        },
        Mullion: {
          staticInfo: {
            contractor: "شرکت آلومینیوم سازی مدرن",
            area: "کل پروژه",
            notes: "بررسی مولیون و ترنزوم ها",
          },
          panels: {
            mullion_default: {
              elementType: "مولیون آلومینیومی",
              elementNumber: "M-001",
              items: [
                { check: "راستای نصب", value: "مطابق" },
                { check: "اتصالات", value: "×" },
                { check: "ضدزنگ", value: "مطابق" },
                { check: "ابعاد", value: "مطابق نقشه" },
              ],
            },
          },
        },
        Bazshow: {
          staticInfo: {
            contractor: "پیمانکار بازشو",
            area: "زون مربوطه",
            notes: "بررسی جزئیات بازشوها",
          },
          panels: {
            Bazshow_default: {
              elementNumber: "BZ-001",
              items: [
                { check: "عملکرد صحیح باز و بست", value: "مطابق" },
                { check: "یراق آلات", value: "بررسی شده" },
                { check: "درزبندی و هوابندی", value: "×" },
                { check: "شیشه (در صورت وجود)", value: "مطابق" },
              ],
            },
          },
        },
      };

      const planNavigationMappings = [
        {
          type: "textAndCircle",
          regex: /^(\d+|[A-Za-z]+[\d-]*)\s+Zone$/i, // Allow alphanumeric zone names
          numberGroupIndex: 1,
          svgFilePattern: "Zone{NUMBER}.svg",
          labelPattern: "Zone {NUMBER}",
          defaultContractor: "پیمانکار پیش‌فرض زون عمومی",
          defaultBlock: "بلوک پیش‌فرض زون عمومی",
        },
        // Example for Plan.svg itself

        // ADD SPECIFIC ZONE DEFAULTS HERE IF NEEDED
        // For example, if Zone09.svg should have a specific contractor:
        {
          svgFile: "Zone09.svg", // EXACT FILENAME
          label: "Zone 09",
          defaultContractor: "شرکت پیمانکار زون 09 مشخص", // Make it obvious it's from this mapping
          defaultBlock: "بلوک ویژه Z9 مشخص",
        },
        {
          svgFile: "Plan.svg",
          label: "Plan اصلی",
          defaultContractor: "پیمانکار پروژه اصلی مشخص",
          defaultBlock: "پروژه اصلی مشخص",
        },
        // Add other specific ID-based or regex mappings for zones as needed
      ];
      const NAV_CIRCLE_PROXIMITY_THRESHOLD = 25;
      const NAV_CIRCLE_DEFAULT_FILL = "rgba(0, 123, 255, 0.4)";
      const NAV_CIRCLE_DEFAULT_STROKE = "rgba(0, 80, 180, 0.7)";
      const NAV_CIRCLE_DEFAULT_STROKE_WIDTH = "1.5px";
      const NAV_CIRCLE_HOVER_STROKE_WIDTH = "3px";
      const NAV_CIRCLE_HOVER_FILL_OPACITY = "0.6";

      function openGlassChecklistForm(elementId, groupId, dynamicContext) {
        // Added dynamicContext
        const staticData = panelChecklistDataStore.Glass.staticInfo;
        const panelData =
          panelChecklistDataStore.Glass.panels[elementId] ||
          panelChecklistDataStore.Glass.panels["glass_default"];

        document.getElementById(
          "glassFormTitle"
        ).textContent = `چک لیست کنترل کیفی - شیشه - المان: ${elementId}`;
        document.getElementById("glassContractor").textContent =
          dynamicContext.contractor || staticData.contractor || "تعیین نشده";
        document.getElementById("glassArea").textContent =
          dynamicContext.areaString || staticData.area || "تعیین نشده"; // Use dynamic area
        document.getElementById("glassType").textContent =
          panelData.glassType || "تعیین نشده";
        document.getElementById("glassNumber").textContent =
          panelData.elementNumber || elementId;

        const checklistBody = document.getElementById("glassChecklistBody");
        checklistBody.innerHTML = "";
        panelData.items.forEach((item) => {
          const row = checklistBody.insertRow();
          const cellCheck = row.insertCell();
          const cellValue = row.insertCell();
          cellCheck.textContent = item.check;
          cellValue.textContent = item.value || "-";
          if (
            item.value &&
            (item.value.includes("×") || item.value.match(/[A-Z]\d+/))
          ) {
            cellValue.classList.add("highlight-issue");
          }
        });

        document.getElementById("glassNotes").textContent =
          dynamicContext.notes || staticData.notes || "";
        document.getElementById("glassChecklistForm").style.display = "block";
      }

      function openBazshowChecklistForm(elementId, groupId, dynamicContext) {
        // Added dynamicContext
        const staticData = panelChecklistDataStore.Bazshow.staticInfo;
        const panelData =
          panelChecklistDataStore.Bazshow.panels[elementId] ||
          panelChecklistDataStore.Bazshow.panels["Bazshow_default"];

        document.getElementById(
          "bazshowFormTitle"
        ).textContent = `چک لیست کنترل کیفی - بازشو - المان: ${elementId}`;
        document.getElementById("bazshowContractor").textContent =
          dynamicContext.contractor || staticData.contractor || "تعیین نشده";
        document.getElementById("bazshowArea").textContent =
          dynamicContext.areaString || staticData.area || "تعیین نشده"; // Use dynamic area
        document.getElementById("bazshowElementNumber").textContent =
          panelData.elementNumber || elementId;

        const checklistBody = document.getElementById("bazshowChecklistBody");
        checklistBody.innerHTML = "";
        if (panelData && panelData.items) {
          panelData.items.forEach((item) => {
            const row = checklistBody.insertRow();
            const cellCheck = row.insertCell();
            const cellValue = row.insertCell();
            cellCheck.textContent = item.check;
            cellValue.textContent = item.value || "-";
            if (
              item.value &&
              (item.value.includes("×") || item.value.match(/[A-Z]\d+/))
            ) {
              cellValue.classList.add("highlight-issue");
            }
          });
        } else {
          checklistBody.innerHTML =
            "<tr><td colspan='2'>اطلاعاتی برای این بازشو یافت نشد.</td></tr>";
        }

        document.getElementById("bazshowNotes").textContent =
          dynamicContext.notes || staticData.notes || "";
        document.getElementById("bazshowChecklistForm").style.display = "block";
      }

      function openMullionChecklistForm(elementId, groupId, dynamicContext) {
        // Added dynamicContext
        const staticData = panelChecklistDataStore.Mullion.staticInfo;
        const panelData =
          panelChecklistDataStore.Mullion.panels[elementId] ||
          panelChecklistDataStore.Mullion.panels["mullion_default"];

        document.getElementById(
          "mullionFormTitle"
        ).textContent = `چک لیست کنترل کیفی - ${groupId} - المان: ${elementId}`;
        document.getElementById("mullionContractor").textContent =
          dynamicContext.contractor || staticData.contractor || "تعیین نشده";
        document.getElementById("mullionArea").textContent =
          dynamicContext.areaString || staticData.area || "تعیین نشده"; // Use dynamic area
        document.getElementById("mullionType").textContent =
          panelData.elementType || groupId || "تعیین نشده";
        document.getElementById("mullionNumber").textContent =
          panelData.elementNumber || elementId;

        const checklistBody = document.getElementById("mullionChecklistBody");
        checklistBody.innerHTML = "";
        panelData.items.forEach((item) => {
          const row = checklistBody.insertRow();
          const cellCheck = row.insertCell();
          const cellValue = row.insertCell();
          cellCheck.textContent = item.check;
          cellValue.textContent = item.value || "-";
          if (
            item.value &&
            (item.value.includes("×") || item.value.match(/[A-Z]\d+/))
          ) {
            cellValue.classList.add("highlight-issue");
          }
        });

        document.getElementById("mullionNotes").textContent =
          dynamicContext.notes || staticData.notes || "";
        document.getElementById("mullionChecklistForm").style.display = "block";
      }
      function showGfrcSubPanelMenu(
        clickedElement,
        subPanelIds,
        dynamicContextForMenu
      ) {
        closeGfrcSubPanelMenu(); // Close any existing menu

        if (!subPanelIds || subPanelIds.length === 0) {
          // If no sub-panels, maybe open a default checklist or show a message
          // For now, let's try to open with the main element's ID if it was a GFRC click
          const panelIdForChecklist =
            clickedElement.dataset.uniquePanelId ||
            clickedElement.dataset.generatedId;
          let checklistPanelData =
            panelChecklistDataStore.GFRC.panels[panelIdForChecklist] ||
            panelChecklistDataStore.GFRC.panels["-G40"];
          if (checklistPanelData) {
            openGfrcChecklistForm(
              panelIdForChecklist,
              checklistPanelData,
              dynamicContextForMenu
            );
          } else {
            alert("اطلاعاتی برای این پنل GFRC یافت نشد.");
          }
          return;
        }

        const menu = document.createElement("div");
        menu.id = "gfrcSubPanelMenu";
        menu.style.position = "absolute";
        menu.style.background = "white";
        menu.style.border = "1px solid #ccc";
        menu.style.padding = "5px";
        menu.style.zIndex = "1001"; // Above forms
        menu.style.boxShadow = "2px 2px 5px rgba(0,0,0,0.2)";
        menu.style.minWidth = "150px";

        subPanelIds.forEach((panelId) => {
          const menuItem = document.createElement("button");
          menuItem.textContent = `چک لیست: ${panelId}`;
          menuItem.style.display = "block";
          menuItem.style.width = "100%";
          menuItem.style.marginBottom = "3px";
          menuItem.style.textAlign = "right";
          menuItem.style.padding = "5px";
          menuItem.onclick = (e) => {
            e.stopPropagation();
            let checklistPanelData =
              panelChecklistDataStore.GFRC.panels[panelId] ||
              panelChecklistDataStore.GFRC.panels["-G40"]; // Fallback
            if (checklistPanelData) {
              // Update the dynamic context's panelOrientation if it's different for sub-panels (if known)
              const updatedDynamicContext = { ...dynamicContextForMenu }; // Create a copy
              // If sub-panel implies orientation, update it. E.g. RF/LF are part of Vertical. UL/DL part of Horizontal.
              if (
                panelId.startsWith("RF-") ||
                panelId.startsWith("LF-") ||
                panelId.startsWith("FF-")
              ) {
                updatedDynamicContext.panelOrientation = "عمودی";
              } else if (
                panelId.startsWith("UL-") ||
                panelId.startsWith("DL-") ||
                panelId.startsWith("FL-")
              ) {
                updatedDynamicContext.panelOrientation = "افقی";
              }
              openGfrcChecklistForm(
                panelId,
                checklistPanelData,
                updatedDynamicContext
              );
            } else {
              alert(`اطلاعات چک لیست برای ${panelId} یافت نشد.`);
            }
            closeGfrcSubPanelMenu();
          };
          menu.appendChild(menuItem);
        });

        const closeButton = document.createElement("button");
        closeButton.textContent = "بستن منو";
        closeButton.style.display = "block";
        closeButton.style.width = "100%";
        closeButton.style.marginTop = "5px";
        closeButton.style.padding = "5px";
        closeButton.style.background = "#f0f0f0";
        closeButton.onclick = (e) => {
          e.stopPropagation();
          closeGfrcSubPanelMenu();
        };
        menu.appendChild(closeButton);

        document.body.appendChild(menu);

        // Position menu near the clicked element
        const rect = clickedElement.getBoundingClientRect(); // SVG element's screen position
        const svgContainerRect = document
          .getElementById("svgContainer")
          .getBoundingClientRect();

        // Adjust for scroll and SVG container offset
        let top = rect.bottom + window.scrollY;
        let left = rect.left + window.scrollX;

        // Ensure menu stays within viewport
        if (left + menu.offsetWidth > window.innerWidth) {
          left = window.innerWidth - menu.offsetWidth - 10;
        }
        if (top + menu.offsetHeight > window.innerHeight) {
          top = window.innerHeight - menu.offsetHeight - 10;
        }
        if (left < 0) left = 10;
        if (top < 0) top = 10;

        menu.style.top = `${top}px`;
        menu.style.left = `${left}px`;

        // Close menu if clicking outside
        setTimeout(() => {
          // Use timeout to avoid immediate close due to event propagation
          document.addEventListener("click", closeGfrcMenuOnClickOutside, {
            once: true,
            capture: true,
          });
        }, 0);
      }

      function closeGfrcSubPanelMenu() {
        const menu = document.getElementById("gfrcSubPanelMenu");
        if (menu) {
          menu.remove();
        }
        document.removeEventListener("click", closeGfrcMenuOnClickOutside, {
          capture: true,
        });
      }
      function closeGfrcMenuOnClickOutside(event) {
        const menu = document.getElementById("gfrcSubPanelMenu");
        if (
          menu &&
          !menu.contains(event.target) &&
          event.target.id !== "gfrcSubPanelMenu"
        ) {
          closeGfrcSubPanelMenu();
        } else if (menu) {
          // If click was inside, re-attach listener for next outside click
          document.addEventListener("click", closeGfrcMenuOnClickOutside, {
            once: true,
            capture: true,
          });
        }
      }

      function makeElementInteractive(element, groupId, elementId) {
        element.classList.add("interactive-element");
        const elementType = svgGroupConfig[groupId]?.elementType || "Generic";

        // --- DETAILED LOGGING FOR DATASET VALUES ---
        const elementIdentifierForMakeInteractive =
          element.id ||
          element.dataset.generatedId ||
          "UnidentifiedElementInMakeInteractive";
        /*  console.log(
          `--- makeElementInteractive for: ${elementIdentifierForMakeInteractive} (Type: ${elementType}) ---`
        );
        console.log(
          `   Raw element.dataset.axisSpan: `,
          element.dataset.axisSpan
        );
        console.log(
          `   Raw element.dataset.floorLevel: `,
          element.dataset.floorLevel
        );
        console.log(
          `   Raw element.dataset.contractor: `,
          element.dataset.contractor
        );
        console.log(`   Raw element.dataset.block: `, element.dataset.block);
        console.log(
          `   Raw element.dataset.panelOrientation: `,
          element.dataset.panelOrientation
        );
        console.log(
          `   Raw element.dataset.uniquePanelId: `,
          element.dataset.uniquePanelId
        );
        console.log(
          `   Raw element.dataset.allSubPanelIds: `,
          element.dataset.allSubPanelIds
        ); */
        // --- END DETAILED LOGGING ---

        const contractor =
          element.dataset.contractor || currentPlanDefaultContractor;
        const block = element.dataset.block || currentPlanDefaultBlock;
        const axisSpan = element.dataset.axisSpan || "نامشخص (از dataset)"; // Add fallback trace
        const floorLevel = element.dataset.floorLevel || "نامشخص (از dataset)"; // Add fallback trace

        const areaString = `زون ${
          currentPlanZoneName || "نامشخص"
        }، بین محورهای ${axisSpan}، طبقه ${floorLevel}`;
        console.log(`   Constructed areaString: ${areaString}`);

        const dynamicContext = {
          contractor: contractor,
          block: block,
          areaString: areaString,
          panelOrientation:
            element.dataset.panelOrientation || "نامشخص (از dataset)",
          deliveryStatus:
            panelChecklistDataStore[elementType === "GFRC" ? "GFRC" : "Glass"]
              ?.staticInfo?.deliveryStatus || "تعیین نشده",
          notes:
            panelChecklistDataStore[elementType === "GFRC" ? "GFRC" : "Glass"]
              ?.staticInfo?.notes || "",
        };
        console.log(
          `   DynamicContext prepared:`,
          JSON.stringify(dynamicContext)
        );
        const clickHandler = (event) => {
          event.stopPropagation();
          closeAllForms(); // Close any other open forms first

          if (elementType === "GFRC") {
            const allSubPanelIdsString = element.dataset.allSubPanelIds;
            let subPanelIds = [];
            try {
              if (allSubPanelIdsString)
                subPanelIds = JSON.parse(allSubPanelIdsString);
            } catch (e) {
              console.error("Error parsing GFRC sub-panel IDs:", e);
            }

            showGfrcSubPanelMenu(element, subPanelIds, dynamicContext);
          } else if (elementType === "Glass") {
            const panelIdForChecklist =
              element.dataset.uniquePanelId || elementId; // Prefer specific ID if available
            openGlassChecklistForm(
              panelIdForChecklist,
              groupId,
              dynamicContext
            ); // Pass dynamicContext
          } else if (elementType === "Mullion" || elementType === "Transom") {
            const panelIdForChecklist =
              element.dataset.uniquePanelId || elementId;
            openMullionChecklistForm(
              panelIdForChecklist,
              groupId,
              dynamicContext
            ); // Pass dynamicContext
          } else if (elementType === "Bazshow") {
            const panelIdForChecklist =
              element.dataset.uniquePanelId || elementId;
            openBazshowChecklistForm(
              panelIdForChecklist,
              groupId,
              dynamicContext
            ); // Pass dynamicContext
          }
        };
        element.addEventListener("click", clickHandler);
        addTouchClickSupport(element, clickHandler);
        console.log(
          `--- End makeElementInteractive for: ${elementIdentifierForMakeInteractive} ---`
        );
      }

      function getElementCenter(element) {
        if (!element) return null;
        try {
          const bbox = element.getBBox();
          if (
            element.tagName.toLowerCase() === "text" &&
            bbox.width === 0 &&
            bbox.height === 0 &&
            !element.textContent.trim()
          ) {
            return null;
          }
          if (
            bbox.width === 0 &&
            bbox.height === 0 &&
            (!element.hasChildNodes() || element.childNodes.length === 0)
          ) {
            if (element.tagName.toLowerCase() === "text") {
              const x = parseFloat(element.getAttribute("x"));
              const y = parseFloat(element.getAttribute("y"));
              const fontSize =
                parseFloat(element.getAttribute("font-size")) || 10;
              if (!isNaN(x) && !isNaN(y)) {
                return { x: x, y: y - fontSize / 3, width: 1, height: 1 };
              }
            }
            return null;
          }
          return {
            x: bbox.x + bbox.width / 2,
            y: bbox.y + bbox.height / 2,
            width: bbox.width,
            height: bbox.height,
          };
        } catch (e) {
          return null;
        }
      }

      function findNearbyCircle(textCenter, allCircles) {
        let closestCircle = null;
        let minDistance = NAV_CIRCLE_PROXIMITY_THRESHOLD;
        if (!textCenter) return null;

        allCircles.forEach((circle) => {
          const circleCx = parseFloat(circle.getAttribute("cx"));
          const circleCy = parseFloat(circle.getAttribute("cy"));
          if (isNaN(circleCx) || isNaN(circleCy)) return;

          const distance = Math.sqrt(
            Math.pow(textCenter.x - circleCx, 2) +
              Math.pow(textCenter.y - circleCy, 2)
          );
          if (distance < minDistance) {
            minDistance = distance;
            closestCircle = circle;
          }
        });
        return closestCircle;
      }
      function makeCircleNavigable(circle, svgFile, description) {
        if (!circle) return;
        if (!circle.parentNode) {
          console.warn(
            `Circle for "${description}" has no parentNode. Skipping DOM manipulations.`
          );
        }

        circle.style.fill = NAV_CIRCLE_DEFAULT_FILL;
        circle.style.stroke = NAV_CIRCLE_DEFAULT_STROKE;
        circle.style.strokeWidth = NAV_CIRCLE_DEFAULT_STROKE_WIDTH;
        circle.style.cursor = "pointer";
        circle.style.pointerEvents = "all";

        let currentCircleForEvents = circle;
        if (circle.parentNode) {
          circle.parentNode.appendChild(circle); // Bring to front
          const newCircle = circle.cloneNode(true);
          try {
            circle.parentNode.replaceChild(newCircle, circle);
            currentCircleForEvents = newCircle;
          } catch (e) {
            console.error(`Error replacing circle for "${description}":`, e);
          }
        }

        // Re-apply styles to ensure they are on the event target
        currentCircleForEvents.style.fill = NAV_CIRCLE_DEFAULT_FILL;
        currentCircleForEvents.style.stroke = NAV_CIRCLE_DEFAULT_STROKE;
        currentCircleForEvents.style.strokeWidth =
          NAV_CIRCLE_DEFAULT_STROKE_WIDTH;
        currentCircleForEvents.style.cursor = "pointer";
        currentCircleForEvents.style.pointerEvents = "all";

        const originalFill = currentCircleForEvents.style.fill;
        const originalStrokeWidth = currentCircleForEvents.style.strokeWidth;

        const clickListener = (event) => {
          event.stopPropagation();
          loadAndDisplaySVG(svgFile);
        };

        const mouseEnterListener = () => {
          currentCircleForEvents.style.fillOpacity =
            NAV_CIRCLE_HOVER_FILL_OPACITY;
          currentCircleForEvents.style.strokeWidth =
            NAV_CIRCLE_HOVER_STROKE_WIDTH;
        };

        const mouseLeaveListener = () => {
          currentCircleForEvents.style.fill = originalFill; // Revert to original fill, not just opacity
          currentCircleForEvents.style.fillOpacity = "1"; // Assuming default opacity if not set
          currentCircleForEvents.style.strokeWidth = originalStrokeWidth;
        };

        currentCircleForEvents.addEventListener("click", clickListener);
        currentCircleForEvents.addEventListener(
          "mouseenter",
          mouseEnterListener
        );
        currentCircleForEvents.addEventListener(
          "mouseleave",
          mouseLeaveListener
        );

        let touchStartTime, touchMoved, touchStartX, touchStartY;
        currentCircleForEvents.addEventListener(
          "touchstart",
          (e) => {
            if (e.touches.length === 1) {
              const touch = e.touches[0];
              touchStartTime = Date.now();
              touchStartX = touch.clientX;
              touchStartY = touch.clientY;
              touchMoved = false;
            }
          },
          { passive: false }
        );
        currentCircleForEvents.addEventListener(
          "touchmove",
          (e) => {
            if (e.touches.length === 1) {
              const touch = e.touches[0];
              if (
                Math.abs(touch.clientX - touchStartX) > 10 ||
                Math.abs(touch.clientY - touchStartY) > 10
              ) {
                touchMoved = true;
              }
            }
          },
          { passive: true }
        );
        currentCircleForEvents.addEventListener("touchend", (e) => {
          if (
            e.changedTouches.length === 1 &&
            !touchMoved &&
            Date.now() - touchStartTime < 400
          ) {
            e.preventDefault();
            e.stopPropagation();
            clickListener(e);
          }
        });
      }

      function setupPlanNavigationLinks(planSvgElement) {
        const allTextElements = Array.from(
          planSvgElement.querySelectorAll("text")
        );
        const allCircleElements = Array.from(
          planSvgElement.querySelectorAll("circle")
        );

        if (allCircleElements.length === 0) {
          console.warn(
            "No circle elements found in Plan.svg to make navigable."
          );
          return;
        }

        planNavigationMappings.forEach((mapping) => {
          allTextElements.forEach((textEl) => {
            const textContent = textEl.textContent
              ? textEl.textContent.trim()
              : "";
            if (!textContent) return;

            let zoneNumber = null;
            let svgFile = mapping.svgFile;
            let label = mapping.label;

            if (mapping.regex && textContent.match(mapping.regex)) {
              const match = textContent.match(mapping.regex);
              if (mapping.numberGroupIndex && match[mapping.numberGroupIndex]) {
                zoneNumber = match[mapping.numberGroupIndex];
                if (mapping.svgFilePattern)
                  svgFile = mapping.svgFilePattern.replace(
                    "{NUMBER}",
                    zoneNumber
                  );
                if (mapping.labelPattern)
                  label = mapping.labelPattern.replace("{NUMBER}", zoneNumber);
              }
              if (!svgFile && mapping.svgFile) svgFile = mapping.svgFile;
              if (!label && mapping.label) label = mapping.label;
            } else if (mapping.ids && mapping.ids.includes(textEl.id)) {
              // This part handles ID-based mappings. It might need adjustment
              // if multiple text elements contribute to one navigation link.
              // For now, assume one text ID directly maps.
              svgFile = mapping.svgFile;
              label = mapping.label;
            }

            if (svgFile && label) {
              const textCenter = getElementCenter(textEl);
              if (textCenter) {
                const nearbyCircle = findNearbyCircle(
                  textCenter,
                  allCircleElements
                );
                if (nearbyCircle) {
                  makeCircleNavigable(nearbyCircle, svgFile, label);
                }
              }
            }
          });

          // Handle mappings based on ID lists specifically, as they might not involve text content regex
          if (
            mapping.type === "idList" &&
            mapping.ids &&
            mapping.ids.length > 0
          ) {
            // Find one of the text elements to get a general position
            const primaryTextEl = planSvgElement.getElementById(mapping.ids[0]);
            if (primaryTextEl) {
              const textCenter = getElementCenter(primaryTextEl);
              if (textCenter) {
                const nearbyCircle = findNearbyCircle(
                  textCenter,
                  allCircleElements
                );
                if (nearbyCircle) {
                  makeCircleNavigable(
                    nearbyCircle,
                    mapping.svgFile,
                    mapping.label
                  );
                } else {
                  console.log(
                    `No circle found near elements for ID-based mapping: "${mapping.label}"`
                  );
                }
              } else {
                console.log(
                  `Could not get center for primary text element of ID-based mapping: "${mapping.label}"`
                );
              }
            } else {
              console.log(
                `Primary text element ID not found for ID-based mapping: "${mapping.label}" (ID: ${mapping.ids[0]})`
              );
            }
          }
        });
      }

      document.addEventListener("DOMContentLoaded", () => {
        const svgContainer = document.getElementById("svgContainer");
        const backToPlanBtn = document.getElementById("backToPlanBtn");

        backToPlanBtn.addEventListener("click", () => {
          loadAndDisplaySVG("Plan.svg");
        });
        loadAndDisplaySVG("Plan.svg"); // Initial load
      });

      function applyGroupStylesAndControls(svgElement) {
        const layerControlsContainer = document.getElementById(
          "layerControlsContainer"
        );
        layerControlsContainer.innerHTML = "";

        for (const groupId in svgGroupConfig) {
          const config = svgGroupConfig[groupId];
          const groupElement = svgElement.getElementById(groupId);
          config.elementRef = groupElement; // Store ref

          if (groupElement) {
            // <<< KEY CHANGE: Only proceed if the group exists in the SVG
            // Group exists, so create a button and apply styles/interactivity

            if (config.color && groupId !== "GFRC") {
              // GFRC has special coloring logic in initializeInteractiveGFRCPanels
              const elementsToColor = groupElement.querySelectorAll(
                config.isTextGroup
                  ? "text, tspan"
                  : "path, rect, circle, polygon, polyline, line, ellipse"
              );
              elementsToColor.forEach((el) => {
                if (config.isTextGroup) {
                  el.style.fill = config.color;
                  el.style.stroke = "none"; // Often good for text layers
                } else {
                  // Special handling for Bazshow to color stroke instead of fill
                  if (
                    groupId === "Bazshow" &&
                    el.tagName.toLowerCase() === "path"
                  ) {
                    el.style.stroke = config.color;
                    if (!el.style.strokeWidth) el.style.strokeWidth = "2px"; // Make sure stroke is visible
                    // el.style.fill = "none"; // Ensure fill remains none if that's intended
                  } else {
                    el.style.fill = config.color;
                  }
                }
              });
            }
            groupElement.style.display = config.defaultVisible ? "" : "none";
            if (config.interactive && config.elementType) {
              console.log(
                `Initializing elements for group: ${groupId}, type: ${config.elementType}`
              );
              initializeElementsByType(
                groupElement,
                config.elementType,
                groupId
              );
            }
            if (config.interactive) {
              const interactiveElements = groupElement.querySelectorAll(
                "path, rect, circle, polygon, polyline, line, ellipse"
              );
              interactiveElements.forEach((el, index) => {
                const elementIdForInteractivity =
                  el.id || `${groupId}_interactive_${index}`;
                // Avoid making navigation circles (already handled) interactive for forms
                if (
                  el.tagName.toLowerCase() === "circle" &&
                  el.style.cursor === "pointer" &&
                  el.style.pointerEvents === "all"
                ) {
                  // This is likely a navigation circle, skip
                } else {
                  // Pass groupId and a unique ID for this specific element for interactivity setup
                  makeElementInteractive(
                    el,
                    groupId,
                    elementIdForInteractivity
                  );
                }
              });
            }

            const button = document.createElement("button");
            button.textContent = config.label;
            button.className = config.defaultVisible ? "active" : "inactive";
            button.addEventListener("click", () => {
              const isVisible = groupElement.style.display !== "none";
              groupElement.style.display = isVisible ? "none" : "";
              button.className = !isVisible ? "active" : "inactive";
            });
            layerControlsContainer.appendChild(button);
          } else {
            // Group defined in config but NOT found in the current SVG.
            // Do NOT create a button for it.
            // console.log(`Layer group '${groupId}' (label: '${config.label}') not found in the current SVG. No button created.`);
          }
        }
      }
      function initializeElementsByType(groupElement, elementType, groupId) {
        const interactiveElements = groupElement.querySelectorAll(
          "path, rect, circle, polygon, polyline, line, ellipse"
        );
        const allTextsInOwningSvg = groupElement.ownerSVGElement
          ? Array.from(groupElement.ownerSVGElement.querySelectorAll("text"))
          : [];
        interactiveElements.forEach((el, index) => {
          const elementId = el.id || `${groupId}_${index}`;
          el.dataset.generatedId = elementId; // Store a general ID

          // 1. Contractor & Block (applies to all types)
          let elContractor = currentPlanDefaultContractor;
          let elBlock = currentPlanDefaultBlock;
          const closestGroupWithId = el.closest("g[id]");
          if (closestGroupWithId && closestGroupWithId.id) {
            const parentGroupId = closestGroupWithId.id;
            if (svgGroupConfig[parentGroupId]) {
              if (svgGroupConfig[parentGroupId].contractor)
                elContractor = svgGroupConfig[parentGroupId].contractor;
              if (svgGroupConfig[parentGroupId].block)
                elBlock = svgGroupConfig[parentGroupId].block;
            }
          }
          el.dataset.contractor = elContractor;
          el.dataset.block = elBlock;

          // 2. Spatial Context (Axis Span, Floor Level)
          const spatialCtx = getElementSpatialContext(el); // Call the (potentially optimized) spatial context
          el.dataset.axisSpan = spatialCtx.axisSpan;
          el.dataset.floorLevel = spatialCtx.floorLevel;
          // Note: derivedId from spatialCtx is a generic fallback. uniquePanelId can be more specific.
          el.dataset.uniquePanelId =
            el.id || spatialCtx.derivedId || `${groupId}_elem_${index}`;

          // 3. Type-Specific Initializations
          if (elementType === "GFRC") {
            const dims = getRectangleDimensions(el.getAttribute("d"));
            if (dims) {
              el.dataset.panelOrientation =
                dims.width > dims.height ? "افقی" : "عمودی";
              if (dims.width > dims.height)
                el.style.fill = "rgba(255, 160, 122, 0.7)";
              else if (dims.height > dims.width)
                el.style.fill = "rgba(32, 178, 170, 0.7)";
              else el.style.fill = "rgba(211, 211, 211, 0.7)";
            }

            let gfrcSubPanelTexts = [];
            let primarySubPanelId = el.dataset.uniquePanelId;
            try {
              const pathBBox = el.getBBox();
              for (const textEl of allTextsInOwningSvg) {
                // Still iterates all, but we can add proximity break
                const content = textEl.textContent.trim();
                if (
                  content.match(/^(FF|RF|LF|UL|FL|DL)-\d+(\([A-Z0-9]+\))?/i)
                ) {
                  try {
                    const textBBox = textEl.getBBox();
                    const textCenterX = textBBox.x + textBBox.width / 2;
                    const textCenterY = textBBox.y + textBBox.height / 2;

                    // Check if text is inside or very near the GFRC path's BBox
                    // Heuristic: check if text center is within a slightly expanded BBox of the path
                    const padding =
                      Math.min(pathBBox.width, pathBBox.height) * 0.2; // 20% padding
                    if (
                      textCenterX >= pathBBox.x - padding &&
                      textCenterX <= pathBBox.x + pathBBox.width + padding &&
                      textCenterY >= pathBBox.y - padding &&
                      textCenterY <= pathBBox.y + pathBBox.height + padding
                    ) {
                      gfrcSubPanelTexts.push(content);
                    }
                  } catch (e) {
                    /* text BBox error */
                  }
                }
              }

              if (gfrcSubPanelTexts.length > 0) {
                primarySubPanelIdForGfrc =
                  gfrcSubPanelTexts.find(
                    (t) =>
                      t.toUpperCase().startsWith("FF-") ||
                      t.toUpperCase().startsWith("FL-")
                  ) || gfrcSubPanelTexts[0];
                el.dataset.uniquePanelId = primarySubPanelIdForGfrc;
              }
            } catch (e) {
              /* BBox error for path */
            }
            el.dataset.allSubPanelIds = JSON.stringify(gfrcSubPanelTexts);
          }
          // Add initializations for Glass, Mullion etc. if they need specific dataset attributes

          // Make interactive (already done by applyGroupStylesAndControls logic)
          makeElementInteractive(el, groupId, elementId); // This call is actually made after this function in the loop of applyGroupStylesAndControls
        });
      }

      function extractAllAxisMarkers(svgElement) {
        currentSvgAxisMarkersX = [];
        currentSvgAxisMarkersY = [];
        if (!svgElement) {
          console.error("extractAllAxisMarkers: svgElement is null!");
          return;
        }
        const allTextsInSvg = Array.from(svgElement.querySelectorAll("text"));

        // Make thresholds less aggressive initially for debugging
        const AXIS_LABEL_Y_THRESHOLD_TOP = currentSvgHeight * 0.25; // top 25%
        const AXIS_LABEL_Y_THRESHOLD_BOTTOM = currentSvgHeight * 0.75; // bottom 25% (i.e. > 75% from top)
        const AXIS_LABEL_X_THRESHOLD_LEFT = currentSvgWidth * 0.25; // left 25%
        const AXIS_LABEL_X_THRESHOLD_RIGHT = currentSvgWidth * 0.75; // right 25% (i.e. > 75% from left)

        console.log(
          `Axis Thresholds: TopY=${AXIS_LABEL_Y_THRESHOLD_TOP}, BottomY=${AXIS_LABEL_Y_THRESHOLD_BOTTOM}, LeftX=${AXIS_LABEL_X_THRESHOLD_LEFT}, RightX=${AXIS_LABEL_X_THRESHOLD_RIGHT}`
        );

        allTextsInSvg.forEach((textEl) => {
          const textContent = textEl.textContent.trim();
          if (!textContent) return;
          try {
            const bbox = textEl.getBBox();
            if (bbox.width === 0 && bbox.height === 0 && !textContent.trim())
              return; // Skip empty or invisible

            const centerX = bbox.x + bbox.width / 2;
            const centerY = bbox.y + bbox.height / 2;

            // Debug individual text elements:
            // if (textContent.match(/^[A-Z]$/i) || textContent.toLowerCase().includes("floor") || textContent.includes("±") || textContent.match(/^\+\d+\.\d+$/)) {
            //     console.log(`Checking text: "${textContent}" at X:${centerX.toFixed(2)}, Y:${centerY.toFixed(2)}`);
            // }

            // X-Axis Markers (Single uppercase letters, near top or bottom)
            if (
              textContent.match(/^[A-Z]$/) &&
              (centerY < AXIS_LABEL_Y_THRESHOLD_TOP ||
                centerY > AXIS_LABEL_Y_THRESHOLD_BOTTOM)
            ) {
              if (!isNaN(centerX) && !isNaN(centerY)) {
                // console.log(`  -> X-AXIS ADDED: ${textContent}`);
                currentSvgAxisMarkersX.push({
                  text: textContent,
                  x: centerX,
                  y: centerY,
                });
              }
            }
            // Y-Axis / Floor Markers
            if (
              textContent.toLowerCase().includes("floor") ||
              textContent.includes("±") ||
              textContent.match(/^\+\d+\.\d+$/)
            ) {
              if (!isNaN(centerX) && !isNaN(centerY)) {
                // console.log(`  -> FLOOR ADDED: ${textContent}`);
                currentSvgAxisMarkersY.push({
                  text: textContent,
                  x: centerX,
                  y: centerY,
                  type: "floor",
                });
              }
            } else if (
              textContent.match(/^[A-Z0-9]+$/i) &&
              (centerX < AXIS_LABEL_X_THRESHOLD_LEFT ||
                centerX > AXIS_LABEL_X_THRESHOLD_RIGHT)
            ) {
              if (!isNaN(centerX) && !isNaN(centerY)) {
                // console.log(`  -> Y-GRID ADDED: ${textContent}`);
                currentSvgAxisMarkersY.push({
                  text: textContent,
                  x: centerX,
                  y: centerY,
                  type: "grid",
                });
              }
            }
          } catch (e) {
            console.warn("BBox error for text:", textContent, e);
          }
        });
        currentSvgAxisMarkersX.sort((a, b) => a.x - b.x);
        currentSvgAxisMarkersY.sort((a, b) => a.y - b.y);
      }

      // --- CORRECTED getElementSpatialContext function ---

      function getElementSpatialContext(element) {
        let axisSpan = "نامشخص (اولیه)";
        let floorLevel = "نامشخص (اولیه)";
        let derivedId = null;

        if (!element) {
          console.error("getElementSpatialContext called with null element");
          return { axisSpan, floorLevel, derivedId };
        }

        const elementIdentifier =
          element.id || element.dataset.generatedId || "UnidentifiedElement"; // Get identifier early for logging

        try {
          const elBBox = element.getBBox(); // This is one BBox call per element, necessary
          const elCenterX = elBBox.x + elBBox.width / 2;
          const elCenterY = elBBox.y + elBBox.height / 2;

          // --- DETAILED LOGGING ---
          console.log(`--- Spatial Context for: ${elementIdentifier} ---`);
          console.log(
            `   Element Center: X=${elCenterX.toFixed(
              2
            )}, Y=${elCenterY.toFixed(2)}`
          );
          /*  console.log(
            `   Available X-Markers (${currentSvgAxisMarkersX.length}):`,
            JSON.stringify(
              currentSvgAxisMarkersX.map((m) => `${m.text} (${m.x.toFixed(0)})`)
            )
          );
          console.log(
            `   Available Floor-Markers (${
              currentSvgAxisMarkersY.filter((m) => m.type === "floor").length
            }):`,
            JSON.stringify(
              currentSvgAxisMarkersY
                .filter((m) => m.type === "floor")
                .map((m) => `${m.text} (${m.y.toFixed(0)})`)
            )
          ); */
          // --- END DETAILED LOGGING ---

          // --- X-Axis Span Logic ---
          if (currentSvgAxisMarkersX.length > 0) {
            let leftMarker = null;
            let rightMarker = null;

            currentSvgAxisMarkersX.forEach((marker) => {
              if (marker.x <= elCenterX) {
                if (!leftMarker || marker.x > leftMarker.x) {
                  leftMarker = marker;
                }
              }
              if (marker.x >= elCenterX) {
                if (!rightMarker || marker.x < rightMarker.x) {
                  rightMarker = marker;
                }
              }
            });

            if (leftMarker && rightMarker) {
              if (
                leftMarker === rightMarker ||
                Math.abs(leftMarker.x - rightMarker.x) < 1
              ) {
                axisSpan = `روی محور ${leftMarker.text}`;
              } else {
                axisSpan = `${leftMarker.text}-${rightMarker.text}`;
              }
            } else if (leftMarker) {
              axisSpan = `>${leftMarker.text}`;
            } else if (rightMarker) {
              axisSpan = `<${rightMarker.text}`;
            } else {
              axisSpan = "خارج محدوده X";
            }
          } else {
            axisSpan = "بدون نشانگر X";
          }

          // --- Floor Level Logic ---
          const floorMarkers = currentSvgAxisMarkersY.filter(
            (m) => m.type === "floor"
          );
          if (floorMarkers.length > 0) {
            let bestMatchFloor = null;
            for (const marker of floorMarkers) {
              if (marker.y <= elCenterY) {
                if (!bestMatchFloor || marker.y > bestMatchFloor.y) {
                  bestMatchFloor = marker;
                }
              }
            }

            if (bestMatchFloor) {
              floorLevel = bestMatchFloor.text;
            } else {
              floorLevel = `< ${floorMarkers[0].text}`;
            }
          } else {
            floorLevel = "بدون نشانگر طبقه";
          }

          // --- Derived ID Logic (Now correctly inside the main try block) ---
          if (
            currentSvgElement &&
            (!element.id || element.id.startsWith("gfrc_path_"))
          ) {
            // Heuristic: only search if ID is generic
            // Try to find text elements near or within the current element.
            // This is still a heuristic. A better way is if text is a child/sibling.
            const MAX_TEXT_SEARCH_RADIUS =
              Math.max(elBBox.width, elBBox.height) * 1.5; // Search in a radius around the element

            const potentialTexts = [];
            if (element.parentNode) {
              // Check siblings and children first
              const siblingsAndChildren = Array.from(
                element.parentNode.children
              );
              siblingsAndChildren.forEach((child) => {
                if (child.tagName.toLowerCase() === "text") {
                  potentialTexts.push(child);
                }
                if (child !== element) {
                  // Avoid re-adding element itself if it's a group
                  Array.from(child.querySelectorAll("text")).forEach((t) =>
                    potentialTexts.push(t)
                  );
                }
              });
            }

            // If not found among siblings/children, expand search slightly (can be costly)
            // For now, let's restrict to a simpler proximity check from all texts if the above fails.
            // This is where the major cost was.
            // We can limit how many texts we check from the global list or be smarter.

            let bestTextMatch = null;
            let minDistanceToText = Infinity;

            // Iterate through *all* texts (this was the slow part).
            // We should try to make this more targeted or limit it.
            // For now, let's keep it but be aware this is a performance bottleneck.
            const allTextsInSvg = Array.from(
              currentSvgElement.querySelectorAll("text")
            );
            for (const textEl of allTextsInSvg) {
              try {
                const textBBox = textEl.getBBox();
                if (
                  textBBox.width === 0 &&
                  textBBox.height === 0 &&
                  !textEl.textContent.trim()
                )
                  continue;

                const textCenterX = textBBox.x + textBBox.width / 2;
                const textCenterY = textBBox.y + textBBox.height / 2;

                // Check if text is within the element's bounding box (good for labels inside)
                const isInside =
                  textCenterX >= elBBox.x &&
                  textCenterX <= elBBox.x + elBBox.width &&
                  textCenterY >= elBBox.y &&
                  textCenterY <= elBBox.y + elBBox.height;

                // Or if text is very close to the element's center (good for labels next to small elements)
                const distance = Math.sqrt(
                  Math.pow(textCenterX - elCenterX, 2) +
                    Math.pow(textCenterY - elCenterY, 2)
                );

                if (isInside || distance < MAX_TEXT_SEARCH_RADIUS * 0.5) {
                  // Prioritize inside or very close
                  const content = textEl.textContent.trim();
                  if (content && !content.match(/^[A-Z]$/)) {
                    // Not a single letter axis
                    if (content.match(/^(FF|RF|LF|UL|FL|DL)-\d+/i)) {
                      // Specific panel ID
                      derivedId = content;
                      break; // Found a good specific ID, stop searching
                    }
                    // If not a specific panel ID, consider it if it's the closest so far
                    if (distance < minDistanceToText) {
                      minDistanceToText = distance;
                      bestTextMatch = content;
                    }
                  }
                }
              } catch (e) {
                /* ignore text BBox error */
              }
            }

            if (!derivedId && bestTextMatch) {
              // If no specific ID found, use the closest text match
              derivedId = bestTextMatch.replace(/[\s\(\)]/g, "_");
            }
          }
          // If derivedId is still null, and uniquePanelId from dataset (set by GFRC logic) isn't available,
          // it will fall back to generatedId in initializeElementsByType.
          // --- End OPTIMIZED Derived ID Logic ---
          // End of the main try block
        } catch (e) {
          console.warn(
            `Error in getElementSpatialContext for ${elementIdentifier}:`,
            e
          );
          // Ensure defaults are returned even if main BBox fails
          axisSpan = "خطا در BBox اصلی";
          floorLevel = "خطا در BBox اصلی";
        }

        console.log(
          `   Final Context for ${elementIdentifier}: Axis='${axisSpan}', Floor='${floorLevel}', DerivedID='${derivedId}'`
        );
        console.log(`--- End Spatial Context for: ${elementIdentifier} ---`);
        return { axisSpan, floorLevel, derivedId };
      }

      function closeAllForms() {
        document.getElementById("gfrcChecklistForm").style.display = "none";
        document.getElementById("glassChecklistForm").style.display = "none";
        document.getElementById("mullionChecklistForm").style.display = "none";
        document.getElementById("bazshowChecklistForm").style.display = "none";
      }
      let regionNavInitialized = false;

      function setupRegionZoneNavigationIfNeeded() {
        if (regionNavInitialized) return;

        const regionSelect = document.getElementById("regionSelect");
        const zoneButtonsContainer = document.getElementById(
          "zoneButtonsContainer"
        );

        if (!regionSelect || !zoneButtonsContainer) {
          console.error("Region/Zone navigation elements not found in DOM.");
          return;
        }

        // Populate regions dropdown
        // Ensure svgGroupConfig is available here
        for (const regionKey in regionToZoneMap) {
          if (regionToZoneMap.hasOwnProperty(regionKey)) {
            const option = document.createElement("option");
            option.value = regionKey;
            // Try to get a more descriptive label from svgGroupConfig if the regionKey exists there
            option.textContent =
              svgGroupConfig[regionKey] && svgGroupConfig[regionKey].label
                ? svgGroupConfig[regionKey].label
                : regionKey;
            regionSelect.appendChild(option);
          }
        }

        regionSelect.addEventListener("change", function () {
          zoneButtonsContainer.innerHTML = ""; // Clear previous zone buttons
          const selectedRegionKey = this.value;
          if (selectedRegionKey && regionToZoneMap[selectedRegionKey]) {
            const zones = regionToZoneMap[selectedRegionKey];
            zones.forEach((zone) => {
              const button = document.createElement("button");
              button.textContent = zone.label;
              // Reuse styles from your existing .navigation-controls button
              button.className = "navigation-controls button"; // This applies multiple classes if 'button' is a separate class
              // If 'button' is a tag selector in .navigation-controls button, this is fine.
              // Or use:
              // button.classList.add('some-base-button-class', 'zone-specific-style');
              // Let's assume your .navigation-controls button style is sufficient:
              // To apply the specific style of buttons inside .navigation-controls:
              // We'll add fixed styling to match, or you can create a generic button class.
              button.style.padding = "8px 12px";
              button.style.borderRadius = "4px";
              button.style.border = "1px solid #007bff";
              button.style.backgroundColor = "#007bff";
              button.style.color = "white";
              button.style.cursor = "pointer";
              button.style.fontFamily = "inherit";
              button.style.margin = "4px"; // Add some spacing for multiple buttons

              button.addEventListener("click", () => {
                loadAndDisplaySVG(zone.svgFile);
              });
              zoneButtonsContainer.appendChild(button);
            });
          }
        });

        regionNavInitialized = true;
      }
      function loadAndDisplaySVG(svgFilename) {
        const svgContainer = document.getElementById("svgContainer");
        svgContainer.innerHTML = "";
        svgContainer.classList.add("loading");
        closeAllForms();
        closeGfrcSubPanelMenu(); // Close GFRC menu if open
        const regionZoneNavContainer = document.getElementById(
          "regionZoneNavContainer"
        );
        if (regionZoneNavContainer) {
          // Check if the element exists
          if (svgFilename.toLowerCase() === "plan.svg") {
            regionZoneNavContainer.style.display = "flex"; // Or 'block' or your preferred display type
            setupRegionZoneNavigationIfNeeded(); // Initialize the dropdown and listeners
          } else {
            regionZoneNavContainer.style.display = "none";
          }
        }
        currentPlanFileName = svgFilename;
        currentPlanZoneName = svgFilename.replace(/\.svg$/i, "");
        console.log(
          `Loading SVG: ${svgFilename}, Zone Name: ${currentPlanZoneName}`
        );

        let planDefaultsFound = false;
        // Reset to a very obvious general default before trying to find a specific one
        currentPlanDefaultContractor = "پیمانکار عمومی ";
        currentPlanDefaultBlock = "بلوک عمومی ";

        for (const mapping of planNavigationMappings) {
          let isMatch = false;
          if (
            mapping.svgFile &&
            mapping.svgFile.toLowerCase() === svgFilename.toLowerCase()
          ) {
            isMatch = true;
          } else if (mapping.svgFilePattern && mapping.regex) {
            // Ensure the regex is for the FILENAME, not just the zone number
            // Example: if pattern is "Zone{NUMBER}.svg", regex should match "ZoneNUMBER.svg"
            // Let's assume your existing regex in planNavigationMappings is for text content,
            // so we might need a different approach for filename matching based on pattern.
            // For now, this part might be tricky. Let's simplify and focus on exact svgFile match first.
            // A simple check:
            if (mapping.svgFilePattern) {
              const patternForFile = mapping.svgFilePattern.replace(
                /\{NUMBER\}/g,
                ".*?"
              ); // crude way to make it a regex
              if (new RegExp(patternForFile, "i").test(svgFilename)) {
                // This is a weak match, needs refinement if you rely on patterns for defaults.
                // isMatch = true; // Temporarily disable complex pattern matching for defaults here
              }
            }
          }

          if (isMatch) {
            console.log(`MATCHED mapping for ${svgFilename}:`, mapping);
            currentPlanDefaultContractor =
              mapping.defaultContractor || "پیمانکار عمومی (از مپینگ)";
            currentPlanDefaultBlock =
              mapping.defaultBlock || "بلوک عمومی (از مپینگ)";
            planDefaultsFound = true;
            break;
          }
        }
        if (!planDefaultsFound) {
          console.warn(
            `No specific default contractor/block mapping for ${svgFilename}. Using global defaults.`
          );
        }
        console.log(
          `Defaults for ${svgFilename}: Contractor='${currentPlanDefaultContractor}', Block='${currentPlanDefaultBlock}'`
        );

        fetch(svgFilename)
          .then((response) => {
            svgContainer.classList.remove("loading");
            if (!response.ok)
              throw new Error(
                `Failed to load ${svgFilename}: ${response.status}`
              );
            return response.text();
          })
          .then((svgData) => {
            svgContainer.innerHTML = svgData;
            const zoomControlsHtml = `<div class="zoom-controls"><button id="zoomInBtn">+</button><button id="zoomOutBtn">-</button><button id="zoomResetBtn">⌂</button></div>`;
            svgContainer.insertAdjacentHTML("afterbegin", zoomControlsHtml);

            setTimeout(() => {
              const svgElement = svgContainer.querySelector("svg");
              if (svgElement) {
                svgElement.style.width = "100%";
                svgElement.style.height = "100%";
                currentSvgElement = svgElement; // Make sure currentSvgElement is set for extractAllAxisMarkers
                currentZoom = 1;
                panX = 0;
                panY = 0;
                updateTransform();
                setupZoomControls();

                currentSvgHeight = svgElement.viewBox.baseVal
                  ? svgElement.viewBox.baseVal.height
                  : svgElement.height.baseVal
                  ? svgElement.height.baseVal.value
                  : 2200;
                currentSvgWidth = svgElement.viewBox.baseVal
                  ? svgElement.viewBox.baseVal.width
                  : svgElement.width.baseVal
                  ? svgElement.width.baseVal.value
                  : 3000;
                console.log(
                  `SVG Dimensions: Width=${currentSvgWidth}, Height=${currentSvgHeight}`
                );

                // 2. Extract axis markers (uses currentSvgElement, currentSvgHeight, currentSvgWidth)
                extractAllAxisMarkers(svgElement);
                console.log(
                  "Extracted X Markers:",
                  JSON.stringify(currentSvgAxisMarkersX)
                );
                console.log(
                  "Extracted Y Markers (Floors):",
                  JSON.stringify(
                    currentSvgAxisMarkersY.filter((m) => m.type === "floor")
                  )
                );

                // 3. Apply styles and initialize elements (uses the extracted markers)
                applyGroupStylesAndControls(svgElement);
                // The individual initialize functions are now called from within applyGroupStylesAndControls
                // by checking config.elementType and calling initializeElementsByType

                if (currentPlanFileName.toLowerCase() === "plan.svg") {
                  // Use currentPlanFileName
                  setupPlanNavigationLinks(svgElement);
                }
              } else {
                console.error("SVG element not found after loading.");
              }
            }, 0);
          })
          .catch((error) => {
            svgContainer.classList.remove("loading");
            console.error(`Error loading/parsing ${svgFilename}:`, error);
            svgContainer.textContent = `Error: ${error.message}. Please check if the file exists and is accessible.`;
          });
      }

      function setupZoomControls() {
        const zoomInBtn = document.getElementById("zoomInBtn");
        const zoomOutBtn = document.getElementById("zoomOutBtn");
        const zoomResetBtn = document.getElementById("zoomResetBtn");
        const svgContainer = document.getElementById("svgContainer");

        if (!zoomInBtn || !zoomOutBtn || !zoomResetBtn || !svgContainer) {
          console.error("Zoom controls or SVG container not found!");
          return;
        }

        zoomInBtn.addEventListener("click", () =>
          zoomSvg(currentZoom + zoomStep)
        );
        zoomOutBtn.addEventListener("click", () =>
          zoomSvg(currentZoom - zoomStep)
        );
        zoomResetBtn.addEventListener("click", resetZoomAndPan);
        svgContainer.addEventListener("wheel", handleWheelZoom, {
          passive: false,
        });
        svgContainer.addEventListener("mousedown", handleMouseDown);
        svgContainer.addEventListener("mousemove", handleMouseMove);
        document.addEventListener("mouseup", handleMouseUp);
        svgContainer.addEventListener("mouseleave", handleMouseUp);
        svgContainer.addEventListener("touchstart", handleTouchStart, {
          passive: false,
        });
        svgContainer.addEventListener("touchmove", handleTouchMove, {
          passive: false,
        });
        document.addEventListener("touchend", handleTouchEnd, {
          passive: false,
        });
      }

      function handleWheelZoom(e) {
        e.preventDefault();
        const svgContainerRect = e.currentTarget.getBoundingClientRect();
        const svgX = (e.clientX - svgContainerRect.left - panX) / currentZoom;
        const svgY = (e.clientY - svgContainerRect.top - panY) / currentZoom;
        const delta = e.deltaY < 0 ? zoomStep : -zoomStep;
        const newZoom = Math.max(
          minZoom,
          Math.min(maxZoom, currentZoom * (1 + delta))
        );
        panX -= svgX * (newZoom - currentZoom);
        panY -= svgY * (newZoom - currentZoom);
        currentZoom = newZoom;
        updateTransform();
        updateZoomButtonStates();
      }
      function handleMouseDown(e) {
        if (
          e.target.closest(".zoom-controls") ||
          e.target.style.cursor === "pointer" ||
          e.target.closest(".interactive-element")
        )
          return;
        isPanning = true;
        panStartX = e.clientX - panX;
        panStartY = e.clientY - panY;
        svgContainer.classList.add("dragging");
      }
      function handleMouseMove(e) {
        if (!isPanning) return;
        e.preventDefault();
        panX = e.clientX - panStartX;
        panY = e.clientY - panStartY;
        updateTransform();
      }
      function handleMouseUp() {
        if (isPanning) {
          isPanning = false;
          svgContainer.classList.remove("dragging");
        }
      }
      function handleTouchStart(e) {
        const targetIsControl = e.target.closest(".zoom-controls");
        const targetIsClickable = e.target.closest(
          '[style*="cursor: pointer"], .interactive-element'
        );

        if (targetIsControl) return;

        window.touchStartOnInteractive = !!targetIsClickable;

        if (e.touches.length === 1) {
          isPanning = true;
          const touch = e.touches[0];
          panStartX = touch.clientX - panX;
          panStartY = touch.clientY - panY;
          window.touchStartX = touch.clientX;
          window.touchStartY = touch.clientY;
          window.touchStartTime = Date.now();
          window.hasMoved = false;
        } else if (e.touches.length === 2) {
          isPanning = false;
          const touch1 = e.touches[0];
          const touch2 = e.touches[1];
          lastTouchDistance = Math.sqrt(
            Math.pow(touch2.clientX - touch1.clientX, 2) +
              Math.pow(touch2.clientY - touch1.clientY, 2)
          );
        }
      }
      function handleTouchMove(e) {
        if (e.touches.length === 1 && isPanning) {
          // Only preventDefault if we are actually panning,
          // to allow scrolling if the touch started on an interactive element but then moved off.
          if (!window.touchStartOnInteractive || window.hasMoved) {
            e.preventDefault();
          }
          const touch = e.touches[0];
          panX = touch.clientX - panStartX;
          panY = touch.clientY - panStartY;
          updateTransform();
          if (window.touchStartX !== undefined) {
            if (
              Math.abs(touch.clientX - window.touchStartX) > 10 ||
              Math.abs(touch.clientY - window.touchStartY) > 10
            ) {
              window.hasMoved = true;
            }
          }
        } else if (e.touches.length === 2) {
          e.preventDefault();
          isPanning = false;
          const touch1 = e.touches[0];
          const touch2 = e.touches[1];
          const currentDistance = Math.sqrt(
            Math.pow(touch2.clientX - touch1.clientX, 2) +
              Math.pow(touch2.clientY - touch1.clientY, 2)
          );
          if (lastTouchDistance > 0) {
            const scaleChange = currentDistance / lastTouchDistance;
            const newZoom = Math.max(
              minZoom,
              Math.min(maxZoom, currentZoom * scaleChange)
            );
            const midX = (touch1.clientX + touch2.clientX) / 2;
            const midY = (touch1.clientY + touch2.clientY) / 2;
            const svgContainerRect = svgContainer.getBoundingClientRect();
            const svgX = (midX - svgContainerRect.left - panX) / currentZoom;
            const svgY = (midY - svgContainerRect.top - panY) / currentZoom;
            panX -= svgX * (newZoom - currentZoom);
            panY -= svgY * (newZoom - currentZoom);
            currentZoom = newZoom;
            updateTransform();
            updateZoomButtonStates();
          }
          lastTouchDistance = currentDistance;
        }
      }
      function handleTouchEnd(e) {
        if (e.touches.length < 2) isPanning = false;
        if (e.touches.length === 0) lastTouchDistance = 0;

        // Check for tap on an interactive element that wasn't handled by its own touchend
        // This is a bit tricky as interactive elements have their own touchend
        // The main purpose here is to correctly reset panning state.

        // The addTouchClickSupport handles taps on interactive elements.
        // This global touchend mainly resets pan/zoom states.

        window.touchStartX = undefined;
        window.touchStartY = undefined;
        window.touchStartTime = undefined;
        window.hasMoved = false;
        window.touchStartOnInteractive = false;
      }

      function addTouchClickSupport(element, clickHandler) {
        let touchStartTime, touchStartX, touchStartY, touchMoved;
        element.addEventListener(
          "touchstart",
          function (e) {
            if (e.touches.length === 1) {
              const touch = e.touches[0];
              touchStartTime = Date.now();
              touchStartX = touch.clientX;
              touchStartY = touch.clientY;
              touchMoved = false;
              e.stopPropagation(); // Prevent container pan/zoom from starting on this element
            }
          },
          { passive: false }
        );

        element.addEventListener(
          "touchmove",
          function (e) {
            if (touchStartTime === undefined || e.touches.length !== 1) return;
            const touch = e.touches[0];
            if (
              Math.abs(touch.clientX - touchStartX) > 10 ||
              Math.abs(touch.clientY - touchStartY) > 10
            ) {
              touchMoved = true;
            }
          },
          { passive: true }
        );

        element.addEventListener("touchend", function (e) {
          if (touchStartTime === undefined || e.changedTouches.length !== 1)
            return;
          if (!touchMoved && Date.now() - touchStartTime < 400) {
            e.preventDefault();
            e.stopPropagation();
            clickHandler(e);
          }
          touchStartTime = undefined;
        });
      }

      function zoomSvg(newZoomFactor) {
        if (!currentSvgElement) return;
        const svgContainerRect = svgContainer.getBoundingClientRect();
        const centerX = svgContainerRect.width / 2;
        const centerY = svgContainerRect.height / 2;
        const svgX = (centerX - panX) / currentZoom;
        const svgY = (centerY - panY) / currentZoom;
        const newZoom = Math.max(minZoom, Math.min(maxZoom, newZoomFactor));
        panX -= svgX * (newZoom - currentZoom);
        panY -= svgY * (newZoom - currentZoom);
        currentZoom = newZoom;
        updateTransform();
        updateZoomButtonStates();
      }
      function updateTransform() {
        if (!currentSvgElement) return;
        currentSvgElement.style.transform = `translate(${panX}px, ${panY}px) scale(${currentZoom})`;
        currentSvgElement.style.transformOrigin = `0 0`;
      }
      function resetZoomAndPan() {
        currentZoom = 1;
        panX = 0;
        panY = 0;
        updateTransform();
        updateZoomButtonStates();
      }
      function updateZoomButtonStates() {
        const zoomInBtn = document.getElementById("zoomInBtn");
        const zoomOutBtn = document.getElementById("zoomOutBtn");
        if (zoomInBtn && zoomOutBtn) {
          zoomInBtn.disabled = currentZoom >= maxZoom;
          zoomOutBtn.disabled = currentZoom <= minZoom;
        }
      }

      function initializeInteractiveGFRCPanels(svg) {
        const gfrcConfig = svgGroupConfig["GFRC"];
        if (
          !gfrcConfig ||
          !svg.getElementById(
            gfrcConfig.elementRef ? gfrcConfig.elementRef.id : "GFRC"
          )
        ) {
          // If GFRC group itself isn't found, try to get its reference from svgGroupConfig if already populated
          const gfrcGroup = svg.getElementById("GFRC");
          if (!gfrcGroup) {
            // console.log("GFRC group not found in this SVG. Skipping GFRC panel initialization.");
            return;
          }
          gfrcConfig.elementRef = gfrcGroup; // Assign if found now
        }
        const gfrcGroupElement = gfrcConfig.elementRef;
        if (!gfrcGroupElement) return;

        const allPathsInGfrc = gfrcGroupElement.querySelectorAll("path");
        const allTextsInSvg = Array.from(svg.querySelectorAll("text")); // All texts in the SVG

        // --- Axis Marker Extraction ---
        let xAxisMarkers = [],
          yAxisMarkers = []; // Changed from yFloorMarkers to generic yAxisMarkers
        const AXIS_LABEL_Y_THRESHOLD_TOP = 300; // Text elements with y < this might be top X-axis labels
        const AXIS_LABEL_Y_THRESHOLD_BOTTOM_FACTOR = 0.8; // Text elements with y > (SVGHeight * factor) might be bottom X-axis labels
        const AXIS_LABEL_X_THRESHOLD_LEFT = 300; // Text elements with x < this might be left Y-axis labels
        const AXIS_LABEL_X_THRESHOLD_RIGHT_FACTOR = 0.8; // Text elements with x > (SVGWidth * factor) might be right Y-axis labels

        let svgHeight = svg.viewBox.baseVal
          ? svg.viewBox.baseVal.height
          : svg.height.baseVal
          ? svg.height.baseVal.value
          : 2200;
        let svgWidth = svg.viewBox.baseVal
          ? svg.viewBox.baseVal.width
          : svg.width.baseVal
          ? svg.width.baseVal.value
          : 3000;

        allTextsInSvg.forEach((textEl) => {
          const textContent = textEl.textContent.trim();
          if (!textContent) return;
          try {
            const bbox = textEl.getBBox();
            const centerX = bbox.x + bbox.width / 2;
            const centerY = bbox.y + bbox.height / 2;

            // Basic X-axis detection (typically horizontal text, near top/bottom)
            // Your example shows single capital letters for axes.
            if (
              textContent.match(/^[A-Z]$/i) &&
              (centerY < AXIS_LABEL_Y_THRESHOLD_TOP ||
                centerY > svgHeight * AXIS_LABEL_Y_THRESHOLD_BOTTOM_FACTOR)
            ) {
              if (!isNaN(centerX) && !isNaN(centerY)) {
                xAxisMarkers.push({
                  text: textContent,
                  x: centerX,
                  y: centerY,
                });
              }
            }
            // Basic Y-axis detection (typically vertical text, near left/right, or horizontal for floor levels)
            // For floor levels:
            if (
              textContent.toLowerCase().includes("floor") ||
              textContent.includes("±") ||
              textContent.match(/^\+\d+\.\d+$/)
            ) {
              if (!isNaN(centerX) && !isNaN(centerY)) {
                yAxisMarkers.push({
                  text: textContent,
                  x: centerX,
                  y: centerY,
                  type: "floor",
                });
              }
            }
            // For Y-axis grid lines (if they are also single letters and positioned vertically)
            else if (
              textContent.match(/^[A-Z]$/i) &&
              (centerX < AXIS_LABEL_X_THRESHOLD_LEFT ||
                centerX > svgWidth * AXIS_LABEL_X_THRESHOLD_RIGHT_FACTOR)
            ) {
              if (!isNaN(centerX) && !isNaN(centerY)) {
                yAxisMarkers.push({
                  text: textContent,
                  x: centerX,
                  y: centerY,
                  type: "grid",
                });
              }
            }
          } catch (e) {
            /* ignore BBox error */
          }
        });

        xAxisMarkers.sort((a, b) => a.x - b.x);
        yAxisMarkers.sort((a, b) => a.y - b.y); // Sort Y markers by their Y position

        function getXAxisSpan(rectCenterX) {
          if (xAxisMarkers.length < 2) return textContent || "نامشخص";
          for (let i = 0; i < xAxisMarkers.length - 1; i++) {
            // Check if center is between the midpoints of current axis and next axis text
            // Or simply if it's between the x-positions of two adjacent axis markers
            if (
              rectCenterX >= xAxisMarkers[i].x &&
              rectCenterX <= xAxisMarkers[i + 1].x
            ) {
              return `${xAxisMarkers[i].text}-${xAxisMarkers[i + 1].text}`;
            }
          }
          if (xAxisMarkers.length > 0) {
            if (rectCenterX < xAxisMarkers[0].x)
              return `<${xAxisMarkers[0].text}`;
            if (rectCenterX > xAxisMarkers[xAxisMarkers.length - 1].x)
              return `>${xAxisMarkers[xAxisMarkers.length - 1].text}`;
          }
          return "X-نامشخص";
        }

        function getFloorLevel(rectCenterY) {
          const floorMarkers = yAxisMarkers.filter((m) => m.type === "floor");
          if (floorMarkers.length === 0) return "طبقه نامشخص";

          for (let i = 0; i < floorMarkers.length; i++) {
            const currentFloor = floorMarkers[i];
            const nextFloor = floorMarkers[i + 1];
            if (nextFloor) {
              if (rectCenterY >= currentFloor.y && rectCenterY < nextFloor.y) {
                return currentFloor.text;
              }
            } else {
              // Last floor marker
              if (rectCenterY >= currentFloor.y) {
                return currentFloor.text;
              }
            }
          }
          if (rectCenterY < floorMarkers[0].y)
            return `<${floorMarkers[0].text}`; // Below the lowest floor marker
          return "F-نامشخص";
        }

        allPathsInGfrc.forEach((path, index) => {
          path.dataset.generatedId = `gfrc_path_${index + 1}`;
          const dAttr = path.getAttribute("d");
          if (!dAttr) return;
          const dims = getRectangleDimensions(dAttr);
          if (dims) {
            // 4- Panel Type (Orientation)
            path.dataset.panelOrientation =
              dims.width > dims.height ? "افقی" : "عمودی";
            if (dims.width > dims.height)
              path.style.fill = "rgba(255, 160, 122, 0.7)";
            else if (dims.height > dims.width)
              path.style.fill = "rgba(32, 178, 170, 0.7)";
            else path.style.fill = "rgba(211, 211, 211, 0.7)";

            // 5- Panel ID (FF-01(AT), etc.)
            let gfrcSubPanelTexts = [];
            let primarySubPanelId = path.dataset.generatedId; // Fallback
            try {
              const pathBBox = path.getBBox();
              allTextsInSvg.forEach((textEl) => {
                const content = textEl.textContent.trim();
                // Regex for FF-01(AT), RF-01, UL-01(ANYTHING), etc.
                if (
                  content.match(/^(FF|RF|LF|UL|FL|DL)-\d+(\([A-Z0-9]+\))?/i)
                ) {
                  try {
                    const textBBox = textEl.getBBox();
                    const textCenterX = textBBox.x + textBBox.width / 2;
                    const textCenterY = textBBox.y + textBBox.height / 2;
                    if (
                      textCenterX >= pathBBox.x &&
                      textCenterX <= pathBBox.x + pathBBox.width &&
                      textCenterY >= pathBBox.y &&
                      textCenterY <= pathBBox.y + pathBBox.height
                    ) {
                      gfrcSubPanelTexts.push(content);
                    }
                  } catch (e) {
                    /* BBox error for text */
                  }
                }
              });
              if (gfrcSubPanelTexts.length > 0) {
                primarySubPanelId =
                  gfrcSubPanelTexts.find(
                    (t) => t.startsWith("FF") || t.startsWith("FL")
                  ) || gfrcSubPanelTexts[0];
              }
            } catch (e) {
              /* BBox error for path */
            }
            path.dataset.uniquePanelId = primarySubPanelId;
            // path.dataset.allSubPanelIds = JSON.stringify(gfrcSubPanelTexts); // If needed later

            // 2- Axis Span
            const rectCenterX = dims.x + dims.width / 2;
            const rectCenterY = dims.y + dims.height / 2;
            path.dataset.axisSpan = getXAxisSpan(rectCenterX);
            path.dataset.floorLevel = getFloorLevel(rectCenterY);

            // 1 & 3- Contractor and Block
            let panelContractor = currentPlanDefaultContractor;
            let panelBlock = currentPlanDefaultBlock;
            const closestGroupWithId = path.closest("g[id]");
            if (closestGroupWithId && closestGroupWithId.id) {
              const groupId = closestGroupWithId.id;
              if (svgGroupConfig[groupId]) {
                if (svgGroupConfig[groupId].contractor)
                  panelContractor = svgGroupConfig[groupId].contractor;
                if (svgGroupConfig[groupId].block)
                  panelBlock = svgGroupConfig[groupId].block;
              }
            }
            path.dataset.contractor = panelContractor;
            path.dataset.block = panelBlock;

            // Interactivity is added by makeElementInteractive via applyGroupStylesAndControls
          }
        });
      }
      function getRectangleDimensions(dAttribute) {
        const commands = dAttribute
          .trim()
          .toUpperCase()
          .split(/(?=[LMCZHV])/);
        let points = [];
        let currentX = 0,
          currentY = 0;
        commands.forEach((commandStr) => {
          const type = commandStr.charAt(0);
          const rawArgs = commandStr.substring(1).trim();
          let args = rawArgs ? rawArgs.split(/[\s,]+/).map(Number) : [];
          let i = 0;
          switch (type) {
            case "M":
              currentX = args[i++];
              currentY = args[i++];
              points.push({ x: currentX, y: currentY });
              while (i < args.length) {
                currentX = args[i++];
                currentY = args[i++];
                points.push({ x: currentX, y: currentY });
              }
              break;
            case "L":
              while (i < args.length) {
                currentX = args[i++];
                currentY = args[i++];
                points.push({ x: currentX, y: currentY });
              }
              break;
            case "H":
              while (i < args.length) {
                currentX = args[i++];
                points.push({ x: currentX, y: currentY });
              }
              break;
            case "V":
              while (i < args.length) {
                currentY = args[i++];
                points.push({ x: currentX, y: currentY });
              }
              break;
            case "Z":
              break;
          }
        });
        if (points.length < 3) return null;
        const xValues = points.map((p) => p.x),
          yValues = points.map((p) => p.y);
        const minX = Math.min(...xValues),
          maxX = Math.max(...xValues);
        const minY = Math.min(...yValues),
          maxY = Math.max(...yValues);
        const width = maxX - minX,
          height = maxY - minY;
        if (width <= 0 || height <= 0) return null;
        return { x: minX, y: minY, width, height, points };
      }

      function openGfrcChecklistForm(panelId, panelData, dynamicContext) {
        if (!panelData || !panelData.items) {
          console.warn(
            `Data for GFRC panel '${panelId}' not found or invalid. Using default GFRC structure if available.`
          );
          // Attempt to use a fallback structure if panelData.items is the issue
          const defaultPanelStructure =
            panelChecklistDataStore.GFRC.panels["-G40"];
          if (defaultPanelStructure && defaultPanelStructure.items) {
            panelData = { ...defaultPanelStructure, ...panelData }; // Merge, keeping specific panelId data if some exists
            if (!panelData.items) panelData.items = defaultPanelStructure.items; // Ensure items exist
          } else {
            alert(
              `داده‌های چک لیست GFRC برای پنل '${panelId}' یافت نشد و ساختار پیش‌فرض نیز موجود نیست.`
            );
            return;
          }
        }

        document.getElementById(
          "gfrcFormTitle"
        ).textContent = `چک لیست کنترل کیفی - GFRC - پنل: ${panelId}`;
        document.getElementById("gfrcContractor").textContent =
          dynamicContext.contractor || "تعیین نشده";
        document.getElementById("gfrcArea").textContent =
          dynamicContext.areaString || "تعیین نشده";
        document.getElementById("gfrcBlock").textContent =
          dynamicContext.block || "تعیین نشده";
        document.getElementById("gfrcDeliveryStatus").textContent =
          dynamicContext.deliveryStatus || "تعیین نشده";
        document.getElementById("gfrcPanelType").textContent =
          dynamicContext.panelOrientation || "تعیین نشده";
        document.getElementById("gfrcPanelNumber").textContent = panelId; // This is the specific ID like FF-01(AT)

        const checklistBody = document.getElementById("gfrcChecklistBody");
        checklistBody.innerHTML = "";
        panelData.items.forEach((item) => {
          const row = checklistBody.insertRow();
          row.insertCell().textContent = item.check;
          const cellValue = row.insertCell();
          cellValue.textContent = item.value || "-";
          if (
            item.value &&
            (item.value.includes("×") || item.value.match(/[A-Z]\d+/))
          )
            cellValue.classList.add("highlight-issue");
        });
        document.getElementById("gfrcNotes").textContent =
          dynamicContext.notes || "";
        document.getElementById("gfrcChecklistForm").style.display = "block";
      }
      function closeForm(formId) {
        document.getElementById(formId).style.display = "none";
      }
    </script>
  </body>
</html>
